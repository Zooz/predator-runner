rules:
  - id: node-postgres-sqli
    patterns:
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern: |
                      $DB.query(...,$QUERY,...)
                  - pattern: |
                      $DB.query(..., $QUERY, ...).$INTFUNC(...)
              - pattern-either:
                  - pattern-inside: |
                      $QUERY = $X + $Y
                      ...
                  - pattern-inside: |
                      $QUERY += $X
                      ...
                  - pattern-inside: |
                      $QUERY = $X.concat($Y)
                      ...
              - pattern-not-inside: |
                  $QUERY += "..."
                  ...
              - pattern-not-inside: |
                  $QUERY = "..." + "..."
                  ...
              - pattern-not-inside: |
                  $QUERY = $X.concat("...")
                  ...
          - pattern: $DB.query(..., $X + $Y, ...)
          - pattern: $DB.query(..., $X.concat($Y), ...)
      - pattern-either:
          - pattern-inside: |
              const { $CLIENT } = require('pg')
              ...
              $DB = new $CLIENT(...)
              ...
          - pattern-inside: |
              const { $POOL } = require('pg')
              ...
              const $NEWPOOL = new $POOL(...)
              ...
              $NEWPOOL.connect((..., $DB, ...) => {
                  ...
              })
      - pattern-not: $DB.query(..., "..." + "...", ...)
      - pattern-not: $DB.query(..., $X.concat("..."), ...)
    languages:
      - js
      - typescript
    message: "Detected string concatenation with a non-literal variable in a
      node-postgres JS SQL statement. This could lead to SQL injection if the
      variable is user-controlled and not properly sanitized. In order to
      prevent SQL injection, used parameterized queries or prepared statements
      instead. You can use parameterized statements like so:
      `client.query('SELECT $1 from table', [userinput])`"
    metadata:
      references:
        - https://node-postgres.com/features/queries
      category: security
      technology:
        - node-postgres
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING

  - id: jose-exposed-data
    message: The object is passed strictly to jose.JWT.sign(...) Make sure that
      sensitive information is not exposed through JWT token payload.
    severity: WARNING
    metadata:
      owasp: "A3: Sensitive Data Exposure"
      cwe: "CWE-522: Insufficiently Protected Credentials"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jose
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    patterns:
      - pattern-inside: |
          require('jose');
          ...
      - pattern-either:
          - patterns:
              - pattern-inside: function (...,$INPUT,...) {...}
              - pattern-either:
                  - pattern: $JOSE.JWT.sign($INPUT,...)
                  - pattern: $JWT.sign($INPUT,...)
          - patterns:
              - pattern-inside: function $F(...,$INPUT,...) {...}
              - pattern-either:
                  - pattern: $JOSE.JWT.sign($INPUT,...)
                  - pattern: $JWT.sign($INPUT,...)

  - id: jwt-exposed-credentials-1
    languages:
      - javascript
      - typescript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      references:
        - https://cwe.mitre.org/data/definitions/522.html
      category: security
      technology:
        - jose
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Password is exposed through JWT token payload. This is not encrypted
      and the password could be compromised. Do not store passwords in JWT
      tokens.
    severity: ERROR
    pattern-either:
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.sign({password:...},...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $T = JWT.sign({password:...},...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = {password:...};
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = {password:...};
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = {password:...};
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = {password:...};
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P.password = ...;
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P.password = ...;
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = Object.assign(...,{password:...},...);
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = Object.assign(...,{password:...},...);
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = Object.assign(...,{password:...},...);
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = Object.assign(...,{password:...},...);
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.sign(Object.assign(...,{password:...},...),...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $T = JWT.sign(Object.assign(...,{password:...},...),...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.sign({$U:{password:...}},...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $T = JWT.sign({$U:{password:...}},...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = {$U:{password:...}};
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = {$U:{password:...}};
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = {$U:{password:...}};
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = {$U:{password:...}};
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P.$U.password = ...;
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P.$U.password = ...;
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = Object.assign(...,{$U:{password:...}},...);
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $P = Object.assign(...,{$U:{password:...}},...);
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = Object.assign(...,{$U:{password:...}},...);
          ...
          var $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $P = Object.assign(...,{$U:{password:...}},...);
          ...
          $T = JWT.sign($P,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);

  - id: hardcoded-jwt-secret-1
    message: "Hardcoded JWT secret or private key is used. This is a Insufficiently
      Protected Credentials weakness:
      https://cwe.mitre.org/data/definitions/522.html Consider using an
      appropriate security mechanism to protect the credentials (e.g. keeping
      secrets in environment variables: process.env.SECRET)"
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jose
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    pattern-either:
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          JWT.verify($P, "...", ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.sign($P, "...", ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $T = JWT.verify($P, "...", ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          JWT.verify($P, JWK.asKey("..."), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $KEY = JWK.asKey("...");
          ...
          JWT.verify($P, $KEY, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $T = JWT.sign($P, JWK.asKey("..."), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $T = JWT.verify($P, JWK.asKey("..."), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $KEY = JWK.asKey("...");
          ...
          var $T = JWT.sign($P, $KEY, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $KEY = JWK.asKey("...");
          ...
          var $T = JWT.verify($P, $KEY, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          JWT.verify($P, $SECRET, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $T = JWT.sign($P, $SECRET, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $T = JWT.verify($P, $SECRET, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          JWT.verify($P, JWK.asKey($SECRET), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $KEY = JWK.asKey($SECRET);
          ...
          JWT.verify($P, $KEY, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $KEY = JWK.asKey($SECRET);
          ...
          var $T = JWT.sign($P, $KEY, ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $SECRET = "...";
          ...
          var $KEY = JWK.asKey($SECRET);
          ...
          var $T = JWT.verify($P, $KEY, ...);

  - id: jwt-none-alg-1
    message: Detected use of the 'none' algorithm in a JWT token. The 'none'
      algorithm assumes the integrity of the token has already been verified.
      This would allow a malicious actor to forge a JWT token that will
      automatically be verified. Do not explicitly use the 'none' algorithm.
      Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.3 Insecue Stateless Session Tokens
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jose
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    pattern-either:
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          var $T = JWT.verify($P, JWK.None,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          $T = JWT.verify($P, JWK.None,...);
      - pattern: |
          var $JOSE = require("jose");
          ...
          var { JWK, JWT } = $JOSE;
          ...
          JWT.verify($P, JWK.None,...);

  - id: jwt-decode-without-verify
    message: Detected the decoding of a JWT token without a verify step. JWT tokens
      must be verified before use, otherwise the token's integrity is unknown.
      This means a malicious actor could forge a JWT token with any claims. Call
      '.verify()' before using the token.
    metadata:
      cwe: "CWE-345: Insufficient Verification of Data Authenticity"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.3 Insecue Stateless Session Tokens
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: WARNING
    patterns:
      - pattern-inside: |
          $JWT = require('jsonwebtoken');
          ...
      - pattern-not-inside: |
          ...
          $JWT.verify($TOKEN, ...)
          ...
      - pattern-not-inside: |
          ...
          if (<... $JWT.verify($TOKEN, ...) ...>) { ... }
          ...
      - pattern: $JWT.decode($TOKEN, ...)

  - id: jwt-exposed-data
    message: The object is passed strictly to jsonwebtoken.sign(...) Make sure that
      sensitive information is not exposed through JWT token payload.
    severity: WARNING
    metadata:
      owasp: "A3: Sensitive Data Exposure"
      cwe: "CWE-522: Insufficiently Protected Credentials"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.3 Insecue Stateless Session Tokens
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    patterns:
      - pattern-inside: |
          $JWT = require('jsonwebtoken');
          ...
      - pattern-either:
          - pattern-inside: function (...,$INPUT,...) {...}
          - pattern-inside: function $F(...,$INPUT,...) {...}
      - pattern: $JWT.sign($INPUT,...)

  - id: jwt-exposed-credentials
    languages:
      - javascript
      - typescript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      references:
        - https://cwe.mitre.org/data/definitions/522.html
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Password is exposed through JWT token payload. This is not encrypted
      and the password could be compromised. Do not store passwords in JWT
      tokens.
    severity: ERROR
    patterns:
      - pattern-inside: |
          $JWT = require("jsonwebtoken");
          ...
      - pattern-either:
          - pattern: |
              $JWT.sign({password:...},...);
          - pattern: |
              $P = {password:...};
              ...
              $JWT.sign($P,...);
          - pattern: |
              $P.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              $P = Object.assign(...,{password:...},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              $JWT.sign({$U:{password:...}},...);
          - pattern: |
              $P = {$U:{password:...}};
              ...
              $JWT.sign($P,...);
          - pattern: |
              $P.$U.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);

  - id: hardcoded-jwt-secret
    message: "Hardcoded JWT secret or private key is used. This is a Insufficiently
      Protected Credentials weakness:
      https://cwe.mitre.org/data/definitions/522.html Consider using an
      appropriate security mechanism to protect the credentials (e.g. keeping
      secrets in environment variables: process.env.SECRET)"
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    patterns:
      - pattern-inside: |
          $JWT = require("jsonwebtoken");
          ...
      - pattern-either:
          - pattern: |
              $JWT.sign($P, "...", ...);
          - pattern: |
              $JWT.verify($P, "...", ...);
          - patterns:
              - pattern-inside: |
                  $SECRET = "...";
                  ...
              - pattern-either:
                  - pattern: $JWT.sign($P, $SECRET, ...)
                  - pattern: $JWT.verify($P, $SECRET, ...)

  - id: jwt-none-alg
    message: Detected use of the 'none' algorithm in a JWT token. The 'none'
      algorithm assumes the integrity of the token has already been verified.
      This would allow a malicious actor to forge a JWT token that will
      automatically be verified. Do not explicitly use the 'none' algorithm.
      Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.3 Insecue Stateless Session Tokens
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    patterns:
      - pattern-inside: |
          $JWT = require("jsonwebtoken");
          ...
      - pattern: $JWT.verify($P, $X, {algorithms:[...,'none',...]},...)

  - id: dangerous-spawn-shell
    metadata:
      cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected non-literal calls to $EXEC(). This could lead to a command
      injection vulnerability.
    patterns:
      - pattern-either:
          - pattern: spawn(...)
          - pattern: spawnSync(...)
          - pattern: $CP.spawn(...)
          - pattern: $CP.spawnSync(...)
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern: >
                      $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["-c", $ARG,
                      ...],...)
                  - patterns:
                      - pattern: $EXEC($CMD,["-c", $ARG, ...],...)
                      - pattern-inside: |
                          $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/"
                          ...
              - pattern-not: |
                  $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["-c", "...", ...],...)
          - patterns:
              - pattern-either:
                  - pattern: |
                      $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",[$ARG, ...],...)
                  - patterns:
                      - pattern: $EXEC($CMD,[$ARG, ...],...)
                      - pattern-inside: |
                          $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/"
                          ...
              - pattern-not: |
                  $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["...", ...],...)
      - pattern-not-inside: |
          $ARG = "..."
          ...
      - pattern-either:
          - pattern-inside: |
              require('child_process')
              ...
          - pattern-inside: |
              import 'child_process'
              ...
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-bracket-object-injection
    patterns:
      - pattern: |
          $VAR = $OBJ[$FIELD];
      - pattern-not: |
          $VAR = $OBJ[($FIELD : float)];
      - pattern-not: |
          $VAR = $OBJ["..."];
      - pattern-not-inside: |
          $FIELD = ...;
          ...
    message: Detected user input used in bracket notation accessor. This could lead
      to object injection through $FIELD, which could grant access to every
      property available in the object and therefore sensitive information.
      Instead, avoid the use of user input in property name fields or create a
      whitelist of allowed input.
    severity: WARNING
    languages:
      - javascript
      - typescript
    metadata:
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]

  - id: detect-non-literal-fs-filename
    patterns:
      - pattern-inside: |
          $X = require('fs')
          ...
      - pattern-not: $FS.$METHOD("...", ...)
      - pattern-either:
          - pattern: $FS.appendFile($FILE,...)
          - pattern: $FS.appendFileSync($FILE,...)
          - pattern: $FS.chmod($FILE,...)
          - pattern: $FS.chmodSync($FILE,...)
          - pattern: $FS.chown($FILE,...)
          - pattern: $FS.chownSync($FILE,...)
          - pattern: $FS.createReadStream($FILE,...)
          - pattern: $FS.createWriteStream($FILE,...)
          - pattern: $FS.exists($FILE,...)
          - pattern: $FS.existsSync($FILE,...)
          - pattern: $FS.lchmod($FILE,...)
          - pattern: $FS.lchmodSync($FILE,...)
          - pattern: $FS.lchown($FILE,...)
          - pattern: $FS.lchownSync($FILE,...)
          - pattern: $FS.link($FILE,...)
          - pattern: $FS.linkSync($FILE,...)
          - pattern: $FS.lstat($FILE,...)
          - pattern: $FS.lstatSync($FILE,...)
          - pattern: $FS.mkdir($FILE,...)
          - pattern: $FS.mkdirSync($FILE,...)
          - pattern: $FS.open($FILE,...)
          - pattern: $FS.openSync($FILE,...)
          - pattern: $FS.readdir($FILE,...)
          - pattern: $FS.readdirSync($FILE,...)
          - pattern: $FS.readFile($FILE,...)
          - pattern: $FS.readFileSync($FILE,...)
          - pattern: $FS.readlink($FILE,...)
          - pattern: $FS.readlinkSync($FILE,...)
          - pattern: $FS.realpath($FILE,...)
          - pattern: $FS.realpathSync($FILE,...)
          - pattern: $FS.rename($FILE,...)
          - pattern: $FS.renameSync($FILE,...)
          - pattern: $FS.rmdir($FILE,...)
          - pattern: $FS.rmdirSync($FILE,...)
          - pattern: $FS.stat($FILE,...)
          - pattern: $FS.statSync($FILE,...)
          - pattern: $FS.symlink($FILE,...)
          - pattern: $FS.symlinkSync($FILE,...)
          - pattern: $FS.truncate($FILE,...)
          - pattern: $FS.truncateSync($FILE,...)
          - pattern: $FS.unlink($FILE,...)
          - pattern: $FS.unlinkSync($FILE,...)
          - pattern: $FS.unwatchFile($FILE,...)
          - pattern: $FS.utimes($FILE,...)
          - pattern: $FS.utimesSync($FILE,...)
          - pattern: $FS.watch($FILE,...)
          - pattern: $FS.watchFile($FILE,...)
          - pattern: $FS.writeFile($FILE,...)
          - pattern: $FS.writeFileSync($FILE,...)
    message: A variable is present in the filename argument of fs calls, this might
      allow an attacker to access anything on your system.
    languages:
      - typescript
      - javascript
    severity: WARNING
    metadata:
      cwe: "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-fs-filename.js
      category: security
      technology:
        - typescript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]

  - id: detect-non-literal-regexp
    patterns:
      - pattern-either:
          - pattern: new RegExp($ARG, ...)
          - pattern: RegExp($ARG, ...)
      - pattern-not: RegExp("...", ...)
      - pattern-not: new RegExp("...", ...)
      - pattern-not: RegExp(/.../, ...)
      - pattern-not: new RegExp(/.../, ...)
    message: RegExp() called with a variable, this might allow an attacker to DOS
      your application with a long-running regular expression.
    languages:
      - javascript
      - typescript
    severity: WARNING
    metadata:
      cwe: "CWE-185: Incorrect Regular Expression"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-regexp.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]

  - id: non-constant-sql-query
    patterns:
      - pattern: $DB.sequelize.query(...)
      - pattern-not: $DB.sequelize.query("...")
    message: Non-constant SQL query detected. Ensure this is not controlled by
      external data, otherwise this is a SQL injection.
    metadata:
      owasp: "A1: Injection"
      cwe: "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      category: security
      technology:
        - sequelize
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: INFO
    languages:
      - javascript
      - typescript

  - id: prototype-pollution-assignment
    languages:
      - javascript
      - typescript
    message: "Possibility of prototype polluting assignment detected. By adding or
      modifying attributes of an object prototype, it is possible to create
      attributes that exist on every object, or replace critical attributes with
      malicious ones. This can be problematic if the software depends on
      existence or non-existence of certain attributes, or uses pre-defined
      attributes of object prototype (such as hasOwnProperty, toString or
      valueOf). Possible mitigations might be: freezing the object prototype,
      using an object without prototypes (via Object.create(null) ), blocking
      modifications of attributes that resolve to object prototype, using Map
      instead of object."
    metadata:
      cwe: "CWE-915: Improperly Controlled Modification of Dynamically-Determined
        Object Attributes"
      category: security
      references:
        - https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING
    patterns:
      - pattern: |
          $X[$B] = ...
      - pattern-inside: |
          $X = $SMTH[$A]
          ...
      - pattern-not-inside: |
          if (<...'constructor' ...>) {
            ...
          }
      - pattern-not-inside: |
          if (<...'__proto__' ...>) {
            ...
          }
      - pattern-not-inside: |
          for(var $B = $S; ...; ...) {...}
      - pattern-not-inside: |
          for($B = $S; ...; ...) {...}
      - pattern-not-inside: |
          $X.forEach(function $NAME($OBJ, $B,...) {...})
      - metavariable-pattern:
          metavariable: $A
          patterns:
            - pattern-not: '"..."'
            - pattern-not: |
                `...${...}...`
            - pattern-not: |
                ($A: float)
      - metavariable-pattern:
          metavariable: $B
          patterns:
            - pattern-not: '"..."'
            - pattern-not: |
                `...${...}...`
            - pattern-not: |
                ($B: float)

  - id: prototype-pollution-function
    languages:
      - javascript
      - typescript
    mode: taint
    metadata:
      cwe: "CWE-915: Improperly Controlled Modification of Dynamically-Determined
        Object Attributes"
      category: security
      references:
        - https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING
    message: "Possibility of prototype polluting function detected. By adding or
      modifying attributes of an object prototype, it is possible to create
      attributes that exist on every object, or replace critical attributes with
      malicious ones. This can be problematic if the software depends on
      existence or non-existence of certain attributes, or uses pre-defined
      attributes of object prototype (such as hasOwnProperty, toString or
      valueOf). Possible mitigations might be: freezing the object prototype,
      using an object without prototypes (via Object.create(null) ), blocking
      modifications of attributes that resolve to object prototype, using Map
      instead of object."
    pattern-sources:
      - pattern-either:
          - patterns:
              - pattern: $SOURCE[$B]
              - pattern-not: $SOURCE["..."]
              - pattern-not: $SOURCE[`...${...}...`]
              - pattern-not: |
                  $SOURCE[($B: float)]
          - pattern: function $X(..., $SOURCE, ...) { ... }
    pattern-sinks:
      - patterns:
          - pattern: $TARGET[$A] = ...
          - pattern-not: $TARGET["..."] = ...
          - pattern-not: |
              $TARGET[($A: float)] = ...
          - pattern-not-inside: |
              if (<... $TARGET.hasOwnProperty($A) ...>) {
                ...
              }
          - pattern-either:
              - pattern-inside: |
                  $NAME = function $F(...) {
                    ...
                    $NAME(...)
                    ...
                  }
              - pattern-inside: |
                  function $NAME(...) {
                    ...
                    $NAME(...)
                    ...
                  }
              - pattern-inside: |
                  function $NAME(...) {
                    ...
                    $THIS.$NAME(...)
                    ...
                  }
              - pattern-inside: |
                  function $NAME(...) {
                    ...
                    $NAME.call(...)
                    ...
                  }
    pattern-sanitizers:
      - patterns:
          - pattern: |
              if (<...'constructor' ...>) {
                ...
              }
              ...
          - pattern: |
              if (<...'__proto__' ...>) {
                ...
              }
              ...

  - id: prototype-pollution-loop
    languages:
      - typescript
      - javascript
    message: "Possibility of prototype polluting function detected. By adding or
      modifying attributes of an object prototype, it is possible to create
      attributes that exist on every object, or replace critical attributes with
      malicious ones. This can be problematic if the software depends on
      existence or non-existence of certain attributes, or uses pre-defined
      attributes of object prototype (such as hasOwnProperty, toString or
      valueOf). Possible mitigations might be: freezing the object prototype,
      using an object without prototypes (via Object.create(null) ), blocking
      modifications of attributes that resolve to object prototype, using Map
      instead of object."
    metadata:
      cwe: "CWE-915: Improperly Controlled Modification of Dynamically-Determined
        Object Attributes"
      category: security
      references:
        - https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf
      technology:
        - typescript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              $SMTH = $SMTH[$A]
          - pattern: |
              $SMTH = $SMTH[$A] = ...
          - pattern: |
              $SMTH = $SMTH[$A] && $Z
          - pattern: |
              $SMTH = $SMTH[$A] || $Z
      - pattern-either:
          - pattern-inside: |
              for(...) {
                ...
              }
          - pattern-inside: |
              while(...) {
                ...
              }
          - pattern-inside: |
              $X.forEach(function $NAME(...) {
                ...
              })
      - pattern-not-inside: |
          for(var $A = $S; ...; ...) {...}
      - pattern-not-inside: |
          for($A = $S; ...; ...) {...}
      - pattern-not-inside: |
          $X.forEach(function $NAME($OBJ, $A,...) {...})
      - metavariable-pattern:
          metavariable: $A
          patterns:
            - pattern-not: '"..."'
            - pattern-not: |
                `...${...}...`
            - pattern-not: |
                ($A: float)

  - id: spawn-shell-true
    patterns:
      - pattern-either:
          - pattern: |
              spawn(...,{shell: $SHELL})
          - pattern: |
              spawnSync(...,{shell: $SHELL})
          - pattern: |
              $CP.spawn(...,{shell: $SHELL})
          - pattern: |
              $CP.spawnSync(...,{shell: $SHELL})
      - pattern-not: |
          spawn(...,{shell: false})
      - pattern-not: |
          spawnSync(...,{shell: false})
      - pattern-not: |
          $CP.spawn(...,{shell: false})
      - pattern-not: |
          $CP.spawnSync(...,{shell: false})
    message: "Found '$SPAWN' with '{shell: $SHELL}'. This is dangerous because this
      call will spawn the command using a shell process. Doing so propagates
      current shell settings and variables, which makes it much easier for a
      malicious actor to execute commands. Use '{shell: false}' instead."
    metadata:
      owasp: "A1: Injection"
      cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: unknown-value-with-script-tag
    patterns:
      - pattern-inside: |
          $UNK = $ANYFUNC(...);
          ...
          $OTHERFUNC(..., <... $UNK ...>, ...);
      - pattern: $OTHERFUNC(..., <... "=~/.*<script.*/" ...>, ...)
    message: Cannot determine what '$UNK' is and it is used with a '<script>' tag.
      This could be susceptible to cross-site scripting (XSS). Ensure '$UNK' is
      not externally controlled, or sanitize this data.
    metadata:
      owasp: "A7: Cross-Site Scripting (XSS)"
      cwe: "CWE-79: Improper Neutralization of Input During Web Page Generation
        ('Cross-site Scripting')"
      references:
        - https://www.developsec.com/2017/11/09/xss-in-a-script-tag/
        - https://github.com/juice-shop/juice-shop/blob/master/routes/videoHandler.ts#L64
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-buffer-noassert
    metadata:
      cwe: "CWE-119: Improper Restriction of Operations within the Bounds of a Memory
        Buffer"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-buffer-noassert.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected usage of noassert in Buffer API, which allows the offset the
      be beyond the end of the buffer. This could result in writing or reading
      beyond the end of the buffer.
    patterns:
      - pattern: $OBJ.$API(..., true)
      - metavariable-regex:
          metavariable: $API
          regex: (read|write)(U?Int8|(U?Int(16|32)|Float|Double)(LE|BE))
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-child-process
    metadata:
      cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected non-literal calls to $EXEC(). This could lead to a command
      injection vulnerability.
    patterns:
      - pattern-either:
          - pattern: exec($CMD,...)
          - pattern: execSync($CMD,...)
          - pattern: spawn($CMD,...)
          - pattern: spawnSync($CMD,...)
      - pattern-not-inside: $EXEC("...",...)
      - pattern-not-inside: $EXEC(["...",...],...)
      - pattern-not-inside: |
          $CMD = "..."
          ...
      - pattern-not-inside: |
          $CMD = ["...",...]
          ...
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-eval-with-expression
    metadata:
      cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated
        Code ('Eval Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-eval-with-expression.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected eval(variable), which could allow a malicious actor to run
      arbitrary code.
    patterns:
      - pattern-either:
          - pattern: eval($OBJ)
          - pattern: window.eval($OBJ)
          - pattern: Function(...,$OBJ)
          - pattern: new Function(...,$OBJ)
      - pattern-not: eval("...")
      - pattern-not: window.eval("...")
      - pattern-not: Function(...,"...")
      - pattern-not: new Function(...,"...")
      - pattern-not-inside: |
          $OBJ = "..."
          ...
          $SOMETHING(..., $OBJ, ...)
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-insecure-websocket
    pattern-regex: ws:\/\/
    languages:
      - regex
    message: Insecure WebSocket Detected. WebSocket Secure (wss) should be used for
      all WebSocket connections.
    metadata:
      asvs:
        section: "V13: API and Web Service Verification Requirements"
        control_id: 13.5.1 Insecure WebSocket
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x21-V13-API.md#v135-websocket-security-requirements
        version: "4"
      category: security
      technology:
        - regex
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    severity: ERROR

  - id: detect-non-literal-require
    metadata:
      cwe: "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated
        Code ('Eval Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected the use of require(variable). Calling require with a
      non-literal argument might allow an attacker to load an run arbitrary
      code, or access arbitrary files.
    patterns:
      - pattern: require($OBJ)
      - pattern-not: require('...')
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: detect-pseudoRandomBytes
    metadata:
      cwe: "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator
        (PRNG)"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-pseudoRandomBytes.js
      asvs:
        section: "V6: Stored Cryptography Verification Requirements"
        control_id: 6.3.1 Insecure Randomness
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v63-random-values
        version: "4"
      category: security
      technology:
        - javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    message: Detected usage of crypto.pseudoRandomBytes, which does not produce
      secure random numbers.
    pattern: crypto.pseudoRandomBytes
    severity: WARNING
    languages:
      - javascript
      - typescript

  - id: spawn-git-clone
    message: Git allows shell commands to be specified in ext URLs for remote
      repositories. For example, git clone 'ext::sh -c whoami% >&2' will execute
      the whoami command to try to connect to a remote repository. Make sure
      that the URL is not controlled by external input.
    metadata:
      cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      category: security
      technology:
        - git
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: spawn('git', ['clone',...,$F])
          - pattern: $X.spawn('git', ['clone',...,$F])
          - pattern: spawn('git', ['clone',...,$P,$F])
          - pattern: $X.spawn('git', ['clone',...,$P,$F])
      - pattern-not: spawn('git', ['clone',...,"..."])
      - pattern-not: $X.spawn('git', ['clone',...,"..."])
      - pattern-not: spawn('git', ['clone',...,"...","..."])
      - pattern-not: $X.spawn('git', ['clone',...,"...","..."])

  - id: hardcoded-passport-secret
    message: "Hardcoded secret used for Passport Strategy. This is a Insufficiently
      Protected Credentials weakness:
      https://cwe.mitre.org/data/definitions/522.html Consider using an
      appropriate security mechanism to protect the credentials (e.g. keeping
      secrets in environment variables: process.env.SECRET)"
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      asvs:
        section: "V3: Session Management Verification Requirements"
        control_id: 3.5.2 Static API keys or secret
        control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
        version: "4"
      category: security
      technology:
        - jwt
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    severity: ERROR
    pattern-either:
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          new $F({clientSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          var $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          var $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          var $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-auth0").Strategy;
          ...
          $S = "...";
          ...
          $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          new $F({clientSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          var $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          var $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth2").Strategy;
          ...
          $S = "...";
          ...
          $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          new $F({secretOrKey: "..."}, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          var $P = {};
          ...
          $P.secretOrKey = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          var $P = {secretOrKey: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          var $S = "...";
          ...
          new $F({secretOrKey: $S}, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.secretOrKey = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {secretOrKey: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $P = {};
          ...
          $P.secretOrKey = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $P = {secretOrKey: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $S = "...";
          ...
          new $F({secretOrKey: $S}, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.secretOrKey = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $S = "...";
          ...
          var $P = {secretOrKey: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.secretOrKey = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-jwt").Strategy;
          ...
          $S = "...";
          ...
          $P = {secretOrKey: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          new $F({consumerSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          var $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          var $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-google-oauth1").Strategy;
          ...
          $S = "...";
          ...
          $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          new $F({clientSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          var $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          var $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth2").Strategy;
          ...
          $S = "...";
          ...
          $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          new $F({clientSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          var $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          var $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          var $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $P = {};
          ...
          $P.clientSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $P = {clientSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $S = "...";
          ...
          new $F({clientSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $S = "...";
          ...
          var $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.clientSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-facebook").Strategy;
          ...
          $S = "...";
          ...
          $P = {clientSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          new $F({consumerSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          var $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          var $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          var $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-twitter").Strategy;
          ...
          $S = "...";
          ...
          $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          new $F({consumerSecret: "..."}, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          var $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          var $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          var $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $P = {};
          ...
          $P.consumerSecret = "...";
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $P = {consumerSecret: "..."};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $S = "...";
          ...
          new $F({consumerSecret: $S}, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $S = "...";
          ...
          var $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $S = "...";
          ...
          var $P = {consumerSecret: $S};
          ...
          new $F($P, ...);
      - pattern: |
          var $F = require("passport-oauth1").Strategy;
          ...
          $S = "...";
          ...
          $P = {};
          ...
          $P.consumerSecret = $S;
          ...
          new $F($P, ...);
      - pattern: |-
          var $F = require("passport-oauth1").Strategy;
          ...
          $S = "...";
          ...
          $P = {consumerSecret: $S};
          ...
          new $F($P, ...);

  - id: unsafe-serialize-javascript
    message: "`serialize-javascript` used with `unsafe` parameter, this could be
      vulnerable to XSS."
    severity: WARNING
    languages:
      - javascript
      - typescript
    metadata:
      owasp: "A1: Injection"
      cwe: "CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page"
      category: security
      technology:
        - serialize-javascript
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    patterns:
      - pattern-inside: |
          $S = require('serialize-javascript');
          ...
      - pattern-not-inside: escape(...)
      - pattern-not-inside: encodeURI(...)
      - pattern: |
          $S(..., {unsafe: true});

  - id: shelljs-exec-injection
    message: If unverified user data can reach the `exec` method it can result in
      Remote Code Execution
    severity: WARNING
    metadata:
      owasp: "A1: Injection"
      cwe: "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      category: security
      technology:
        - shelljs
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    languages:
      - javascript
      - typescript
    patterns:
      - pattern-inside: |
          require('shelljs');
          ...
      - pattern-not-inside: |
          require('shelljs');
          ...
          var $INPUT = "...";
          ...
      - pattern: $SHELL.exec($INPUT,...)
      - pattern-not: $SHELL.exec("...",...)
